import com.github.spotbugs.snom.SpotBugsTask
import java.util.concurrent.TimeUnit

plugins {
    id 'java'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.13'
    id 'com.netflix.nebula.ospackage' version '11.10.0'
    id 'org.owasp.dependencycheck' version '12.1.9'
}

subprojects {

    apply plugin: "checkstyle"
    apply plugin: "com.github.spotbugs"

    checkstyle {
        toolVersion = '10.20.0'
        configFile file("${rootDir}/config/checkstyle/checkstyle.xml")
    }

    checkstyleMain {
        source = 'src/main/java'
    }
    checkstyleTest {
        source = 'src/test/java'
    }

    tasks.withType(Checkstyle).configureEach {
        reports {
            xml.required = false
            html.required = true
        }
    }

    spotbugs {
        toolVersion = '4.8.3'
        effort = 'max'
        reportLevel = 'low'
    }

    tasks.withType(SpotBugsTask).configureEach {
        reports {
            xml.required = false
            html.required = true
        }
    }

    tasks.register("spotbugsMain", SpotBugsTask) {
        classes.setFrom(files(layout.buildDirectory.dir("classes/java/main")))
        source.setFrom(files("src/main/java"))
        classpath.setFrom(files(layout.buildDirectory.dir("classes/java/main")))
        reports.html.outputLocation.set(layout.buildDirectory.file("reports/spotbugs/main.html"))
    }

    tasks.register("spotbugsTest", SpotBugsTask) {
        classes.setFrom(files(layout.buildDirectory.dir("classes/java/test")))
        source.setFrom(files("src/test/java"))
        classpath.setFrom(files(
                layout.buildDirectory.dir("classes/java/test"),
                configurations.testRuntimeClasspath
        ))
        reports.html.outputLocation.set(layout.buildDirectory.file("reports/spotbugs/test.html"))
    }

    check.dependsOn("spotbugsMain", "spotbugsTest")
}

repositories {
    mavenCentral()
}
dependencyCheck {
    nvd {
        // Read API key from a system property 'nvd.apiKey'
        apiKey = System.getProperty("nvd.apiKey")
    }
}
dependencies {
    implementation libs.bouncycastle
    implementation libs.jcommander

    compileOnly libs.lombok
    annotationProcessor libs.lombok

    testImplementation libs.junit.jupiter
    testRuntimeOnly libs.junit.platform.launcher

    testCompileOnly libs.lombok
    testAnnotationProcessor libs.lombok

    implementation 'org.hirs:HIRS_Utils'
}



// Dependency resolutions
configurations.configureEach {
    exclude group: 'commons-logging', module: 'commons-logging'

    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        if (details.requested.group == 'org.apache.logging.log4j') {
            details.useVersion '2.25.3' // Force upgraded log4j version
        }
        if (details.requested.group == 'org.apache.httpcomponents' &&
                details.requested.name == 'httpclient') {
            details.useVersion '4.5.14'  // Force upgraded httpclient version
        }
    }
}

tasks.register('updateGitSubmodules', Exec) {
    commandLine 'git', 'submodule', 'update', '--init', '--recursive'
    description = 'Updates (and initializes) git submodules'
}

tasks.register('checkstyleSingle', Checkstyle) {
    description = 'Runs Checkstyle on a single file'
    def error = ""
    println description
    if (project.hasProperty('filename')) {
        File name = file(project.getProperty('filename'))
        if (name.exists()) {
            println "Processing file: $name"
            classpath = files()
            configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
            source = file(project.getProperty('filename'))
            include '**/*.java'
            reports {
                xml.required = false
                html.required = true
            }
        } else {
            error= "Error processing file, does path/file exist?"
            throw new GradleException(error)
        }
    } else {
        error = "Error: No filename provided. Use -Pfilename=<path/to/file>"
        throw new GradleException(error)
    }
}


tasks.named('build') {
    dependsOn(updateGitSubmodules)
}

test {
    useJUnitPlatform()
}


def buildTime = { ->
    Date latestdate = new Date()
    def time = latestdate.getTime()
    long seconds = TimeUnit.MILLISECONDS.toSeconds(time)
    return seconds
}

def gitHash = { ->
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--short', 'HEAD'
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

def projectVersion = rootProject.file('VERSION').text.trim()
def packageVersion= "${projectVersion}.${buildTime}.${gitHash}.el9"

jar {
    archiveVersion = projectVersion
    // Keep jar clean:
    exclude 'META-INF/*.SF', 'META-INF/*.DSA', 'META-INF/*.RSA', 'META-INF/*.MF'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    manifest {
        attributes(
                "Main-Class": "rimtool.Main",
                'Class-Path':configurations.runtimeClasspath.files.collect { it.getName() }.join(' ')
        )
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    into('lib') {
        from 'libs'
    }
}

ospackage {
    packageName = 'rim-tool'
    os = LINUX
    arch = NOARCH
    version = "$packageVersion"
    release = '1'

    user 'root'
    fileMode = 0755

    // Incompatible with older version
    conflicts('tcg-rim-tool')

    into('/opt/rimtool/lib') {
        from jar.outputs.files
        from configurations.runtimeClasspath
        from 'libs'
    }

    into('/opt/rimtool/scripts') {
        from('scripts') {
            exclude {
                FileTreeElement details ->
                    details.file.name.endsWith('.bat')
            }
        }
    }
    into('/opt/rimtool/docs') {
        from('./') {
            include {
                FileTreeElement details ->
                    details.file.name.endsWith('.md')
            }
        }
    }
    into('/opt/rimtool/data') {
        from('data') {
        }
    }
    link("/usr/local/bin/rim", "/opt/rimtool/scripts/rimtool.sh", 0x755)

    // Post Install
    postInstall "echo ${projectVersion} > /opt/rimtool/VERSION"
    // Post Uninstall
    postUninstall 'rm -rf /opt/rimtool'
}

buildRpm {
    arch = X86_64
}

buildDeb {
    arch = 'amd64'
}
